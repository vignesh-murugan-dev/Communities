name: Send Push Notifications

on:
  workflow_dispatch:
    inputs:
      title:
        description: 'Notification Title'
        required: true
        default: 'Tamil Nadu Tech Update'
      body:
        description: 'Notification Body'
        required: true
        default: 'New tech event available!'
      url:
        description: 'Notification URL (optional)'
        required: false
        default: '/'
      test_mode:
        description: 'Test mode (sends to limited recipients)'
        type: boolean
        required: false
        default: true
  push:
    paths:
      - 'src/data/events.json'

jobs:
  send-notifications:
    runs-on: ubuntu-latest
    name: Send Push Notifications

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure full git history
        run: |
          git fetch --unshallow || true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq curl

      - name: Detect events.json changes
        id: detect-changes
        if: github.event_name == 'push'
        run: |
          echo "Detecting changes in events.json..."

          # Check if this is the first commit or if we have previous commits
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            echo "Previous commit exists, checking for changes..."
            
            # Get the changed files
            git diff --name-only HEAD~1 HEAD > changed_files.txt
            
            if grep -q "src/data/events.json" changed_files.txt; then
              echo "events_changed=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Events.json has been modified"
              
              # Get the actual changes (added events)
              git show HEAD:src/data/events.json > new_events.json
              git show HEAD~1:src/data/events.json > old_events.json
            echo "Contents of new_events.json:"
            cat new_events.json
            echo "Contents of old_events.json:"
            cat old_events.json
              
              # Find new events by comparing arrays (objects in new_events.json not in old_events.json)
              NEW_EVENT=$(jq -r '
                (input_filename == "new_events.json") as $new |
                (input_filename == "old_events.json") as $old |
                (.[0] - .[1]) | if length > 0 then .[0] else empty end
              ' new_events.json old_events.json 2>/dev/null || echo "{}")
              
              if [ "$NEW_EVENT" != "{}" ] && [ "$NEW_EVENT" != "null" ] && [ -n "$NEW_EVENT" ]; then
                echo "new_event_found=true" >> $GITHUB_OUTPUT
                echo "$NEW_EVENT" > detected_event.json
                
                # Extract event details
                EVENT_NAME=$(echo "$NEW_EVENT" | jq -r '.eventName // "New Tech Event"')
                EVENT_DESCRIPTION=$(echo "$NEW_EVENT" | jq -r '.eventDescription // ""')
                EVENT_DATE=$(echo "$NEW_EVENT" | jq -r '.eventDate // ""')
                EVENT_TIME=$(echo "$NEW_EVENT" | jq -r '.eventTime // ""')
                EVENT_VENUE=$(echo "$NEW_EVENT" | jq -r '.eventVenue // ""')
                EVENT_LINK=$(echo "$NEW_EVENT" | jq -r '.eventLink // ""')
                LOCATION=$(echo "$NEW_EVENT" | jq -r '.location // ""')
                COMMUNITY_NAME=$(echo "$NEW_EVENT" | jq -r '.communityName // ""')
                
                echo "event_name=$EVENT_NAME" >> $GITHUB_OUTPUT
                echo "event_description=$EVENT_DESCRIPTION" >> $GITHUB_OUTPUT
                echo "event_date=$EVENT_DATE" >> $GITHUB_OUTPUT
                echo "event_time=$EVENT_TIME" >> $GITHUB_OUTPUT
                echo "event_venue=$EVENT_VENUE" >> $GITHUB_OUTPUT
                echo "event_link=$EVENT_LINK" >> $GITHUB_OUTPUT
                echo "location=$LOCATION" >> $GITHUB_OUTPUT
                echo "community_name=$COMMUNITY_NAME" >> $GITHUB_OUTPUT
                
                echo "üéâ New event detected: $EVENT_NAME"
                echo "üìç Location: $LOCATION"
                echo "üè¢ Community: $COMMUNITY_NAME"
                echo "üìÖ Date: $EVENT_DATE at $EVENT_TIME"
              else
                echo "new_event_found=false" >> $GITHUB_OUTPUT
                echo "No new events found in the changes"
              fi
            else
              echo "events_changed=false" >> $GITHUB_OUTPUT
              echo "events.json was not modified"
            fi
          else
            echo "First commit or no previous commits - checking if events.json exists and has content"
            
            if [ -f "src/data/events.json" ]; then
              echo "events_changed=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Events.json exists (first commit scenario)"
              
              # For first commit, get the first event from the file
              FIRST_EVENT=$(jq -r '.[0] // empty' src/data/events.json 2>/dev/null || echo "{}")
              
              if [ "$FIRST_EVENT" != "{}" ] && [ "$FIRST_EVENT" != "null" ] && [ -n "$FIRST_EVENT" ]; then
                echo "new_event_found=true" >> $GITHUB_OUTPUT
                echo "$FIRST_EVENT" > detected_event.json
                
                # Extract event details
                EVENT_NAME=$(echo "$FIRST_EVENT" | jq -r '.eventName // "New Tech Event"')
                EVENT_DESCRIPTION=$(echo "$FIRST_EVENT" | jq -r '.eventDescription // ""')
                EVENT_DATE=$(echo "$FIRST_EVENT" | jq -r '.eventDate // ""')
                EVENT_TIME=$(echo "$FIRST_EVENT" | jq -r '.eventTime // ""')
                EVENT_VENUE=$(echo "$FIRST_EVENT" | jq -r '.eventVenue // ""')
                EVENT_LINK=$(echo "$FIRST_EVENT" | jq -r '.eventLink // ""')
                LOCATION=$(echo "$FIRST_EVENT" | jq -r '.location // ""')
                COMMUNITY_NAME=$(echo "$FIRST_EVENT" | jq -r '.communityName // ""')
                
                echo "event_name=$EVENT_NAME" >> $GITHUB_OUTPUT
                echo "event_description=$EVENT_DESCRIPTION" >> $GITHUB_OUTPUT
                echo "event_date=$EVENT_DATE" >> $GITHUB_OUTPUT
                echo "event_time=$EVENT_TIME" >> $GITHUB_OUTPUT
                echo "event_venue=$EVENT_VENUE" >> $GITHUB_OUTPUT
                echo "event_link=$EVENT_LINK" >> $GITHUB_OUTPUT
                echo "location=$LOCATION" >> $GITHUB_OUTPUT
                echo "community_name=$COMMUNITY_NAME" >> $GITHUB_OUTPUT
                
                echo "üéâ First event detected: $EVENT_NAME"
                echo "üìç Location: $LOCATION"
                echo "üè¢ Community: $COMMUNITY_NAME"
                echo "üìÖ Date: $EVENT_DATE at $EVENT_TIME"
              else
                echo "new_event_found=false" >> $GITHUB_OUTPUT
                echo "No events found in events.json"
              fi
            else
              echo "events_changed=false" >> $GITHUB_OUTPUT
              echo "events.json does not exist"
            fi
          fi

      - name: Clone subscriptions repo
        env:
          GH_DB_PAT: ${{ secrets.GH_DB_PAT }}
        run: |
          git clone https://x-access-token:${GH_DB_PAT}@github.com/sarveshmrao/communities-notification-subs.git subs_repo

      - name: Get all subscription files
        id: get-files
        run: |
          cd subs_repo
          ls *.json > ../subscription_files.txt || echo "No subscription files found"
          FILE_COUNT=$(wc -l < ../subscription_files.txt)
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "First 5 subscription files:"
          head -5 ../subscription_files.txt

      - name: Prepare notification payload
        id: prepare-payload
        run: |
          # Determine notification content based on trigger type
          if [ "${{ github.event_name }}" = "push" ] && [ "${{ steps.detect-changes.outputs.new_event_found }}" = "true" ]; then
            echo "Creating notification for new event..."
            
            # Use detected event information
            TITLE="üéâ New Tech Event: ${{ steps.detect-changes.outputs.event_name }}"
            BODY="üìÖ ${{ steps.detect-changes.outputs.event_date }} at ${{ steps.detect-changes.outputs.event_time }} in ${{ steps.detect-changes.outputs.location }}"
            URL="${{ steps.detect-changes.outputs.event_link }}"
            
            # Truncate title and body if too long
            TITLE=$(echo "$TITLE" | cut -c1-100)
            BODY=$(echo "$BODY" | cut -c1-150)
            
            cat > notification_payload.json << EOF
          {
            "title": "$TITLE",
            "body": "$BODY",
            "url": "$URL",
            "test": false,
            "eventData": {
              "eventName": "${{ steps.detect-changes.outputs.event_name }}",
              "eventDate": "${{ steps.detect-changes.outputs.event_date }}",
              "eventTime": "${{ steps.detect-changes.outputs.event_time }}",
              "location": "${{ steps.detect-changes.outputs.location }}",
              "communityName": "${{ steps.detect-changes.outputs.community_name }}",
              "eventLink": "${{ steps.detect-changes.outputs.event_link }}"
            },
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Creating manual notification..."
            
            cat > notification_payload.json << EOF
          {
            "title": "${{ inputs.title }}",
            "body": "${{ inputs.body }}",
            "url": "${{ inputs.url }}",
            "test": ${{ inputs.test_mode }},
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          else
            echo "No notification content to prepare"
            echo '{}' > notification_payload.json
          fi

          echo "Notification payload prepared:"
          cat notification_payload.json

      - name: Send notifications to subscribers
        id: send-notifications
        if: |
          steps.get-files.outputs.file_count > 0 && (
            (github.event_name == 'push' && steps.detect-changes.outputs.new_event_found == 'true') ||
            github.event_name == 'workflow_dispatch'
          )
        env:
          VAPID_PUBLIC_KEY: ${{ secrets.VAPID_PUBLIC_KEY }}
          VAPID_PRIVATE_KEY: ${{ secrets.VAPID_PRIVATE_KEY }}
        run: |
          npm install -g web-push

          TOTAL_FILES=$(cat subscription_files.txt | wc -l)
          SENT_COUNT=0
          FAILED_COUNT=0

          # Determine if this is test mode
          IS_TEST_MODE="false"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ inputs.test_mode }}" = "true" ]; then
            IS_TEST_MODE="true"
          fi

          # Limit in test mode
          if [ "$IS_TEST_MODE" = "true" ]; then
            echo "Test mode enabled - limiting to first 3 subscriptions"
            head -3 subscription_files.txt > test_files.txt
            mv test_files.txt subscription_files.txt
            TOTAL_FILES=$(cat subscription_files.txt | wc -l)
          fi

          echo "Processing $TOTAL_FILES subscriptions..."
          echo "Event trigger: ${{ github.event_name }}"
          echo "Test mode: $IS_TEST_MODE"

          NOTIFICATION_PAYLOAD=$(cat notification_payload.json | jq -c .)

          while read -r FILE_NAME; do
            if [ -z "$FILE_NAME" ]; then
              continue
            fi

            echo "Processing subscription file: $FILE_NAME"
            SUBSCRIPTION_DATA=$(cat subs_repo/"$FILE_NAME")
            echo "$SUBSCRIPTION_DATA"

            ENDPOINT=$(echo "$SUBSCRIPTION_DATA" | jq -r '.endpoint // empty')
            P256DH=$(echo "$SUBSCRIPTION_DATA" | jq -r '.keys.p256dh // empty')
            AUTH=$(echo "$SUBSCRIPTION_DATA" | jq -r '.keys.auth // empty')

            if [ -z "$ENDPOINT" ] || [ -z "$P256DH" ] || [ -z "$AUTH" ]; then
              echo "‚ùå Invalid subscription data in $FILE_NAME"
              FAILED_COUNT=$((FAILED_COUNT + 1))
              continue
            fi

            echo "Sending notification to: ${ENDPOINT:0:50}..."

            if web-push send-notification \
              --endpoint="$ENDPOINT" \
              --key="$P256DH" \
              --auth="$AUTH" \
              --vapid-subject="mailto:your-email@domain.com" \
              --vapid-pubkey="$VAPID_PUBLIC_KEY" \
              --vapid-pvtkey="$VAPID_PRIVATE_KEY" \
              --payload="$NOTIFICATION_PAYLOAD" \
              --ttl=3600 2>/dev/null; then
              echo "‚úÖ Successfully sent notification to $FILE_NAME"
              SENT_COUNT=$((SENT_COUNT + 1))
            else
              echo "‚ùå Failed to send notification to $FILE_NAME"
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi

            sleep 0.2

          done < subscription_files.txt

          echo "üéâ Notification send completed!"
          echo "üìä Results:"
          echo "   Total processed: $TOTAL_FILES"
          echo "   Successfully sent: $SENT_COUNT"
          echo "   Failed: $FAILED_COUNT"
          if [ "$TOTAL_FILES" -gt 0 ]; then
            echo "   Success rate: $(( SENT_COUNT * 100 / TOTAL_FILES ))%"
          fi

          echo "total_processed=$TOTAL_FILES" >> $GITHUB_OUTPUT
          echo "sent_count=$SENT_COUNT" >> $GITHUB_OUTPUT
          echo "failed_count=$FAILED_COUNT" >> $GITHUB_OUTPUT

      - name: Summary report
        run: |
          echo "## üì± Push Notification Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger Information:**" >> $GITHUB_STEP_SUMMARY
          echo "- Trigger: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "- Events Changed: ${{ steps.detect-changes.outputs.events_changed }}" >> $GITHUB_STEP_SUMMARY
            echo "- New Event Found: ${{ steps.detect-changes.outputs.new_event_found }}" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.detect-changes.outputs.new_event_found }}" = "true" ]; then
              echo "- Event Name: ${{ steps.detect-changes.outputs.event_name }}" >> $GITHUB_STEP_SUMMARY
              echo "- Community: ${{ steps.detect-changes.outputs.community_name }}" >> $GITHUB_STEP_SUMMARY
              echo "- Location: ${{ steps.detect-changes.outputs.location }}" >> $GITHUB_STEP_SUMMARY
              echo "- Date: ${{ steps.detect-changes.outputs.event_date }} at ${{ steps.detect-changes.outputs.event_time }}" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Notification Details:**" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "- Title: ${{ inputs.title }}" >> $GITHUB_STEP_SUMMARY
            echo "- Body: ${{ inputs.body }}" >> $GITHUB_STEP_SUMMARY
            echo "- URL: ${{ inputs.url }}" >> $GITHUB_STEP_SUMMARY
            echo "- Test Mode: ${{ inputs.test_mode }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Results:**" >> $GITHUB_STEP_SUMMARY
          echo "- Subscription files found: ${{ steps.get-files.outputs.file_count }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.get-files.outputs.file_count }}" -gt "0" ]; then
            echo "- Notifications sent: ${{ steps.send-notifications.outputs.sent_count || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Failed notifications: ${{ steps.send-notifications.outputs.failed_count || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Total processed: ${{ steps.send-notifications.outputs.total_processed || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Status: ‚ö†Ô∏è No subscribers found" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Timestamp: $(date -u)*" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        run: |
          rm -f subscription_files.txt notification_payload.json test_files.txt
          rm -rf subs_repo
